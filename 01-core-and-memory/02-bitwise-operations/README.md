# 02-bitwise-operations

## 學習目標：
本練習旨在精通 C 語言的**位元運算 (Bitwise Operations)** 與**前置處理器巨集 (Preprocessor Macros)**，並將兩者結合，應用於嵌入式系統中最常見的情境：**硬體暫存器操作 (Hardware Register Manipulation)**。

完成本單元後，你將能夠：
1.  熟練運用 `&`, `|`, `^`, `~`, `<<`, `>>` 等位元運算子。
2.  理解四大核心操作：**設定 (Set)**、**清除 (Clear)**、**翻轉 (Toggle)**、**讀取 (Read)** 特定位元。
3.  學會使用 `#define` 建立**帶有參數的巨集 (Macros with Arguments)**，以提升程式碼的可讀性和可維護性。
4.  模擬一個硬體週邊 (如 GPIO)，並為其設計一組清晰、易用的暫存器操作 API。

---

## 核心觀念 (Core Concepts)

### 1. 為何需要直接操作位元？
在嵌入式系統中，硬體的功能是由一個個**記憶體映射暫存器 (Memory-Mapped Registers)** 控制的。這些暫存器中的每一個位元 (bit) 通常都有特殊意義，例如：
-   **控制位 (Control Bit)**：設定某個位元為 1 可能會啟用一個功能 (如：啟用 UART 接收)，設為 0 則停用。
-   **狀態位 (Status Bit)**：讀取某個位元可能代表硬體的狀態 (如：ADC 轉換是否完成)。
-   **設定值 (Configuration Value)**：某幾個位元組合起來可能代表一個設定值 (如：設定 GPIO 的工作模式是輸入還是輸出)。

因此，我們必須有能力精確地只修改我們想動的位元，而完全不影響同一個暫存器裡的其他位元。這就是位元運算派上用場的地方。

### 2. 六大位元運算子 (Bitwise Operators)
| 運算子 | 名稱 | 範例 | 說明 |
| :--- | :--- | :--- | :--- |
| `&` | AND | `A & B` | 兩個位元皆為 1，結果才是 1。 |
| `|` | OR  | `A \| B` | 兩個位元只要有 1，結果就是 1。   |
| `^` | XOR | `A ^ B` | 兩個位元不同時，結果為 1。 |
| `~` | NOT | `~A` | 將所有位元反相 (0 變 1，1 變 0)。|
| `<<` | 左移 | `A << n` | 將 A 的所有位元向左移動 n 位，右邊補 0。 |
| `>>` | 右移 | `A >> n` | 將 A 的所有位元向右移動 n 位。 |

### 3. 四大核心操作的實現

假設我們要操作第 `n` 個位元 (bit `n`)。核心技巧是先用左移運算子 `(1U << n)` 創造一個只在第 `n` 位元是 1，其餘位元都是 0 的**遮罩 (Mask)**。

-   **設定 (Set) - `|` (OR)**：將某位元設為 1，不影響其他位元。
    -   `REGISTER |= (1U << n);`
    -   **原理**：任何位元與 0 做 OR 運算都維持原樣 (`x | 0 = x`)；與 1 做 OR 運算則變為 1 (`x | 1 = 1`)。

-   **清除 (Clear) - `&` (AND) + `~` (NOT)**：將某位元設為 0，不影響其他位元。
    -   `REGISTER &= ~(1U << n);`
    -   **原理**：`~(1U << n)` 會產生一個只有第 `n` 位是 0，其餘都是 1 的遮罩。任何位元與 1 做 AND 運算都維持原樣 (`x & 1 = x`)；與 0 做 AND 運算則變為 0 (`x & 0 = 0`)。

-   **翻轉 (Toggle) - `^` (XOR)**：反轉某位元的狀態 (0變1，1變0)。
    -   `REGISTER ^= (1U << n);`
    -   **原理**：任何位元與 0 做 XOR 運算都維持原樣 (`x ^ 0 = x`)；與 1 做 XOR 運算則會反相 (`x ^ 1 = ~x`)。

-   **讀取 (Read) - `&` (AND)**：檢查某位元的狀態。
    -   `bit_status = (REGISTER >> n) & 1U;`
    -   **原理**：先用 `&` 搭配遮罩分離出目標位元，再透過右移將其移到最右邊 (第 0 位)，方便判斷是 0 還是 1。

### 4. 可讀性高的前置處理器巨集

直接在程式碼中寫 `GPIOB->ODR |= (1 << 5);` 雖然能動，但可讀性極差，幾個月後可能連自己都看不懂 `5` 代表什麼。我們可以利用 `#define` 將這些操作封裝成語意清晰的巨集。

-   **定義位元位置 (Bit Position)**
    ```c
    #define LED_PIN 5
    ```

-   **定義暫存器操作巨集**
    ```c
    // 泛用的位元操作巨集
    #define BIT_SET(REG, POS)     ((REG) |= (1U << (POS)))
    #define BIT_CLEAR(REG, POS)   ((REG) &= ~(1U << (POS)))
    #define BIT_TOGGLE(REG, POS)  ((REG) ^= (1U << (POS)))
    #define BIT_READ(REG, POS)    (((REG) >> (POS)) & 1U)
    ```
    **注意**：在定義巨集時，將所有參數和整個表達式用括號 `()` 包起來是一個非常重要的好習慣，可以避免因運算子優先級導致的非預期錯誤。

---